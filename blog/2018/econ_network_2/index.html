<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>A snapshot of economics, part 2 - visualizing the network | Martin Stancsics</title> <meta name="author" content="Martin Stancsics"/> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¾</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://stanmart.github.io/blog/2018/econ_network_2/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">MartinÂ </span>Stancsics</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/papers/">papers</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">A snapshot of economics, part 2 - visualizing the network</h1> <p class="post-meta">October 27, 2018</p> <p class="post-tags"> <a href="/blog/2018"> <i class="fas fa-calendar fa-sm"></i> 2018 </a> Â  Â· Â  <a href="/blog/tag/network"> <i class="fas fa-hashtag fa-sm"></i> network</a> Â  <a href="/blog/tag/economics"> <i class="fas fa-hashtag fa-sm"></i> economics</a> Â  <a href="/blog/tag/visualization"> <i class="fas fa-hashtag fa-sm"></i> visualization</a> Â  <a href="/blog/tag/holoviews"> <i class="fas fa-hashtag fa-sm"></i> holoviews</a> Â  <a href="/blog/tag/datashader"> <i class="fas fa-hashtag fa-sm"></i> datashader</a> Â  <a href="/blog/tag/gephi"> <i class="fas fa-hashtag fa-sm"></i> gephi</a> Â  </p> </header> <article class="post-content"> <p>The <a href="http://stanmart.github.io/network/web/scraping/python/econlit/ebscohost/2018/10/25/econ-network-1/">last article</a> focused on collecting data on the economics literature (from a legal and a technical standpoint). Here is a short primer if you have not read it.</p> <p>Every article published in the field of economics is assigned a few (usually 2-5) JEL (Journal of Economic Literature) codes by the authors which define the subfields it belongs to. This system of classification is hierarchical: the codes consist of a letter (main category) followed by two numbers. You can find the list <a href="https://www.aeaweb.org/econlit/jelCodes.php?view=jel" target="_blank" rel="noopener noreferrer">here</a>.</p> <p>As a project for a network science cource, Olena Chystiakova and I attempted to analyze, visualize and model the network of these classifications. We use the number of articles containing a pair of JEL codes as the measure of the strength of association between the two subfields. In order to do this, we have downloaded the JEL codes (and some other metadata) of every article published in the field of economics in 2014 that could be found in the Econlit database. This article will deal with the transformation and the visualization of this data.</p> <h2 id="projection-to-jel-codes">Projection to JEL codes</h2> <p>We will start by processing a data into network format. Let us import it into a <code class="language-plaintext highlighter-rouge">pandas.DataFrame</code> and see how the downloaded database looks!</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sqlite3</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="sh">"</span><span class="s">data/full_database.db</span><span class="sh">"</span><span class="p">)</span>
<span class="n">articles_wide</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_sql</span><span class="p">(</span><span class="sh">"</span><span class="s">SELECT an, jel FROM articles</span><span class="sh">"</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
<span class="n">articles_wide</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div> <table> <thead> <tr> <th>an</th> <th>jel</th> </tr> </thead> <tbody> <tr> <td>1419951</td> <td>B31; G30; M40</td> </tr> <tr> <td>1419952</td> <td>G34; L25; M12; M52</td> </tr> <tr> <td>1419953</td> <td>D24; G31; L14; L23; L24; L25; M41</td> </tr> <tr> <td>1419954</td> <td>D82; G12; G32; L25; M41</td> </tr> <tr> <td>1419955</td> <td>G32; G34; G38; L25; M42; M48</td> </tr> </tbody> </table> <p>For every article (identified by an article number, <code class="language-plaintext highlighter-rouge">an</code>) we have all of the JEL codes it is associated with. Unfortunately, the JEL codes are stored as a string delimited by semicolons. In order to turn it into a proper edgelist between article and JEL code nodes, it has to be transformed it so that each row of the <code class="language-plaintext highlighter-rouge">jel</code> column contains exactly one JEL code.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">articles_series</span> <span class="o">=</span> <span class="p">(</span><span class="n">articles_wide</span><span class="p">[</span><span class="n">articles_wide</span><span class="p">[</span><span class="sh">"</span><span class="s">jel</span><span class="sh">"</span><span class="p">]</span> <span class="o">!=</span> <span class="sh">""</span><span class="p">]</span>
                   <span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="p">[(</span><span class="n">row</span><span class="p">.</span><span class="n">an</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">row</span><span class="p">.</span><span class="n">jel</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">"</span><span class="s">; </span><span class="sh">"</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">articles_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">articles_series</span><span class="p">:</span>
    <span class="n">articles_list</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    
<span class="n">articles_long</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">articles_list</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">an</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">jel</span><span class="sh">"</span><span class="p">])</span>
<span class="n">articles_long</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div> <table> <thead> <tr> <th>an</th> <th>jel</th> </tr> </thead> <tbody> <tr> <td>1419951</td> <td>B31</td> </tr> <tr> <td>1419951</td> <td>G30</td> </tr> <tr> <td>1419951</td> <td>M40</td> </tr> <tr> <td>1419952</td> <td>G34</td> </tr> <tr> <td>1419952</td> <td>L25</td> </tr> </tbody> </table> <p>Now we that we have the <em>bipartite graph</em> (i.e. a graph whose nodes areseparable into two groups, with edges only connecting nodes from different groups), we can use NetworkX to project it to the nodes representing JEL codes, thereby producing an undirected weighed graph where the nodes are the JEL codes.</p> <p>First we create the bipartite graph by creating an empty node, adding the article nodes, adding the JEL nodes, and finally adding the edges.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>

<span class="n">bipart_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nc">Graph</span><span class="p">()</span>
<span class="n">bipart_graph</span><span class="p">.</span><span class="nf">add_nodes_from</span><span class="p">(</span><span class="n">articles_long</span><span class="p">.</span><span class="n">an</span><span class="p">.</span><span class="nf">unique</span><span class="p">(),</span> <span class="n">bipart</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">bipart_graph</span><span class="p">.</span><span class="nf">add_nodes_from</span><span class="p">(</span><span class="n">articles_long</span><span class="p">.</span><span class="n">jel</span><span class="p">.</span><span class="nf">unique</span><span class="p">(),</span> <span class="n">bipart</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">bipart_graph</span><span class="p">.</span><span class="nf">add_edges_from</span><span class="p">(</span><span class="n">articles_long</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="p">(</span><span class="n">row</span><span class="p">.</span><span class="n">an</span><span class="p">,</span> <span class="n">row</span><span class="p">.</span><span class="n">jel</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div> <p>Then we can use the <code class="language-plaintext highlighter-rouge">weighted_projected_graph</code> function from the <code class="language-plaintext highlighter-rouge">networkx.projection</code> module to project the bipartite graph to one set of nodes, with the weight of nodes representing the number of articles through which two JEL codes are connected. Then, as we are not interested in disconnected nodes, we select the giant component of the projection.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jel_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">bipartite</span><span class="p">.</span><span class="n">projection</span><span class="p">.</span><span class="nf">weighted_projected_graph</span><span class="p">(</span><span class="n">bipart_graph</span><span class="p">,</span>
                                                             <span class="n">articles_long</span><span class="p">.</span><span class="n">jel</span><span class="p">.</span><span class="nf">unique</span><span class="p">())</span>
<span class="n">jel_graph_giant</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">nx</span><span class="p">.</span><span class="nf">connected_component_subgraphs</span><span class="p">(</span><span class="n">jel_graph</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</code></pre></div></div> <h2 id="visualization-preliminaries">Visualization preliminaries</h2> <p>This far the graph is just a set of nodes and a set of edges connecting them. In order to plot it, we need to assign (x, y) coordinates to each node. This can be done by using functions from the <code class="language-plaintext highlighter-rouge">networkx.drawing</code> module. In this example, a force-directed algorithm is used, which places strongly connected nodes (measured by the edge weight) closer to each other.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fr_layout</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="n">drawing</span><span class="p">.</span><span class="nf">fruchterman_reingold_layout</span><span class="p">(</span><span class="n">jel_graph_giant</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Now we need to convert the <code class="language-plaintext highlighter-rouge">networkx</code> graph to a format that can be handled by <code class="language-plaintext highlighter-rouge">holoviews</code> and <code class="language-plaintext highlighter-rouge">datashader</code>: a <code class="language-plaintext highlighter-rouge">pandas.DataFrame</code>with the columns containing the various attributes of the nodes [name, x-coordinate, y-coordinate, JEL category, and weighed degree (the number of edges connected to a node, or in the weighed case, the sum of their weights)].</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">node_df</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">.</span><span class="nf">from_dict</span><span class="p">(</span><span class="n">fr_layout</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">y</span><span class="sh">"</span><span class="p">])</span>
           <span class="p">.</span><span class="nf">reset_index</span><span class="p">()</span>
           <span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">index</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">}))</span>
<span class="n">node_df</span><span class="p">[</span><span class="sh">"</span><span class="s">category</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_df</span><span class="p">[</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">astype</span><span class="p">(</span><span class="sh">"</span><span class="s">category</span><span class="sh">"</span><span class="p">)</span>
<span class="n">degree_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">jel_graph_giant</span><span class="p">.</span><span class="nf">degree</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">degree</span><span class="sh">"</span><span class="p">]).</span><span class="nf">set_index</span><span class="p">(</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">)</span>
<span class="n">node_df</span> <span class="o">=</span> <span class="n">node_df</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">degree_df</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">node_df</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div> <table> <thead> <tr> <th>name</th> <th>x</th> <th>y</th> <th>category</th> <th>degree</th> </tr> </thead> <tbody> <tr> <td>K33</td> <td>-0.335445</td> <td>0.084594</td> <td>K</td> <td>589</td> </tr> <tr> <td>C81</td> <td>-0.606666</td> <td>0.115445</td> <td>C</td> <td>272</td> </tr> <tr> <td>D45</td> <td>0.664908</td> <td>0.800432</td> <td>D</td> <td>152</td> </tr> <tr> <td>I18</td> <td>0.158935</td> <td>-0.143668</td> <td>I</td> <td>2931</td> </tr> <tr> <td>O55</td> <td>-0.951587</td> <td>-0.080761</td> <td>O</td> <td>6</td> </tr> </tbody> </table> <p>Now we need to do the same with edges. As we will use functions from the <code class="language-plaintext highlighter-rouge">datashader.bundling</code> module later on, we need a very specific format (<code class="language-plaintext highlighter-rouge">holoviews</code> would be more flexible): a <code class="language-plaintext highlighter-rouge">pandas.DataFrame</code> having the columns <code class="language-plaintext highlighter-rouge">source</code> and <code class="language-plaintext highlighter-rouge">target</code>, indicating the <em>index</em> of the nodes that the edge connects, and optionally a column of weights. It may have more columns, but it needs to have <code class="language-plaintext highlighter-rouge">source</code> and <code class="language-plaintext highlighter-rouge">target</code> at a minimum.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">edge_df_names</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nf">to_pandas_edgelist</span><span class="p">(</span><span class="n">jel_graph_giant</span><span class="p">).</span><span class="nf">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">source</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">source_name</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">target</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">target_name</span><span class="sh">"</span><span class="p">})</span>
<span class="n">name_index_key</span> <span class="o">=</span> <span class="n">node_df</span><span class="p">[</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">].</span><span class="nf">reset_index</span><span class="p">().</span><span class="nf">set_index</span><span class="p">(</span><span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">)</span>
<span class="n">edge_df</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_df_names</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">name_index_key</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">index</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">source</span><span class="sh">"</span><span class="p">}),</span> <span class="n">left_on</span><span class="o">=</span><span class="sh">'</span><span class="s">source_name</span><span class="sh">'</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                        <span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">name_index_key</span><span class="p">.</span><span class="nf">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">index</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">target</span><span class="sh">"</span><span class="p">}),</span> <span class="n">left_on</span><span class="o">=</span><span class="sh">'</span><span class="s">target_name</span><span class="sh">'</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="n">edge_df</span><span class="p">.</span><span class="nf">head</span><span class="p">()</span>
</code></pre></div></div> <table> <thead> <tr> <th>source_name</th> <th>target_name</th> <th>weight</th> <th>source</th> <th>target</th> </tr> </thead> <tbody> <tr> <td>K33</td> <td>G34</td> <td>3</td> <td>0</td> <td>305</td> </tr> <tr> <td>D45</td> <td>G34</td> <td>1</td> <td>2</td> <td>305</td> </tr> <tr> <td>I18</td> <td>G34</td> <td>4</td> <td>3</td> <td>305</td> </tr> <tr> <td>O34</td> <td>G34</td> <td>5</td> <td>6</td> <td>305</td> </tr> <tr> <td>I25</td> <td>G34</td> <td>1</td> <td>7</td> <td>305</td> </tr> </tbody> </table> <h2 id="visualizing-the-network">Visualizing the network</h2> <p>We will use <code class="language-plaintext highlighter-rouge">holoviews</code> to annotate our data, complemented by <code class="language-plaintext highlighter-rouge">datashader</code> to properly visualize the many overlapping edges. We also utilize the <code class="language-plaintext highlighter-rouge">bokeh</code> extension of <code class="language-plaintext highlighter-rouge">holoviews</code> so that the resulting graphs will be interactive (supporting panning, zooming and tooltips). That said, they will be fully interactive if a python kernel is running (in this case <code class="language-plaintext highlighter-rouge">datashader</code> recomputes the shading with each change of view) and somewhat interactive if they are exported as Javascript (the edges will be a fixed image, so no rerendering on zooming, but tooltips and panning would work properly). On this blog however, the plots will be static images.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">holoviews</span> <span class="k">as</span> <span class="n">hv</span>
<span class="kn">from</span> <span class="n">holoviews.operation.datashader</span> <span class="kn">import</span> <span class="n">datashade</span><span class="p">,</span> <span class="n">bundle_graph</span>
<span class="n">hv</span><span class="p">.</span><span class="nf">extension</span><span class="p">(</span><span class="sh">"</span><span class="s">bokeh</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>We start by creating a <code class="language-plaintext highlighter-rouge">Nodes</code> object, which is a representation of the graphâ€™s nodes. The key dimensions will be the coordinates and the indices, and we also add the JEL category and the log-degree of the node as value dimensions. Then, we create a <code class="language-plaintext highlighter-rouge">Graph</code> object by using the previously created <code class="language-plaintext highlighter-rouge">nodes</code> and adding two additional key dimensions: the source and target node of each edge. We will also use the edge weight as a value dimension.</p> <p>There will be two versions of the graph:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">graph</code>, where each edge is drawn straight from source to target, and</li> <li> <code class="language-plaintext highlighter-rouge">bundled_graph</code>, where edges closed to each other are bundled together.</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">colors</span> <span class="o">=</span> <span class="n">hv</span><span class="p">.</span><span class="nc">Cycle</span><span class="p">(</span><span class="sh">'</span><span class="s">Category20</span><span class="sh">'</span><span class="p">).</span><span class="n">values</span>

<span class="n">nodes</span> <span class="o">=</span> <span class="n">hv</span><span class="p">.</span><span class="nc">Nodes</span><span class="p">((</span><span class="n">node_df</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node_df</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">node_df</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">node_df</span><span class="p">.</span><span class="n">category</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">node_df</span><span class="p">.</span><span class="n">degree</span><span class="p">)</span> <span class="o">/</span> <span class="mi">15</span><span class="p">),</span>
                 <span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">Category</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">log_degree</span><span class="sh">"</span><span class="p">])</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">hv</span><span class="p">.</span><span class="nc">Graph</span><span class="p">(((</span><span class="n">edge_df</span><span class="p">.</span><span class="n">source</span><span class="p">,</span> <span class="n">edge_df</span><span class="p">.</span><span class="n">target</span><span class="p">,</span> <span class="n">edge_df</span><span class="p">.</span><span class="n">weight</span><span class="p">),</span> <span class="n">nodes</span><span class="p">),</span>
                 <span class="n">vdims</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">Weight</span><span class="sh">"</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">A snapshot of economics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">redim</span><span class="p">.</span><span class="nf">range</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.05</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)).</span><span class="nf">options</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>

<span class="n">bundled_graph</span> <span class="o">=</span> <span class="nf">bundle_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="sh">"</span><span class="s">Weight</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Everything is set: our data is annotated, so we just need to print it to plot it. A slight twist is that we plot the nodes and the edges separately, as we do not want to datashade the former.</p> <p>We can use the <code class="language-plaintext highlighter-rouge">%%opts</code> ipython magic to set some display properties, and also to map the categories to node colors and log-degrees to node sizes. Then we utilize the <code class="language-plaintext highlighter-rouge">datashade</code> function from the <code class="language-plaintext highlighter-rouge">holoviews.operation.datashader</code> module to map the edges to pixels according to density, and use the <code class="language-plaintext highlighter-rouge">*</code> operator to place the two plots on top of each other.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">opts</span> <span class="n">Nodes</span> <span class="p">[</span><span class="n">color_index</span><span class="o">=</span><span class="sh">'</span><span class="s">Category</span><span class="sh">'</span> <span class="n">size_index</span><span class="o">=</span><span class="sh">'</span><span class="s">log_degree</span><span class="sh">'</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span> <span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">colors</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
<span class="o">%%</span><span class="n">opts</span> <span class="n">Graph</span> <span class="p">[</span><span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span>
<span class="nf">datashade</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="sh">'</span><span class="s">eq_hist</span><span class="sh">'</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">cyan</span><span class="sh">'</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span> <span class="o">*</span> <span class="n">graph</span><span class="p">.</span><span class="n">nodes</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/econ_network/count_edges-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/econ_network/count_edges-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/econ_network/count_edges-1400.webp"></source> <img src="/assets/img/econ_network/count_edges.png" width="600" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">opts</span> <span class="n">Nodes</span> <span class="p">[</span><span class="n">color_index</span><span class="o">=</span><span class="sh">'</span><span class="s">Category</span><span class="sh">'</span> <span class="n">size_index</span><span class="o">=</span><span class="sh">'</span><span class="s">log_degree</span><span class="sh">'</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span> <span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">colors</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
<span class="o">%%</span><span class="n">opts</span> <span class="n">Graph</span> <span class="p">[</span><span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span>
<span class="nf">datashade</span><span class="p">(</span><span class="n">bundled_graph</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="sh">'</span><span class="s">eq_hist</span><span class="sh">'</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">cyan</span><span class="sh">'</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span> <span class="o">*</span> <span class="n">bundled_graph</span><span class="p">.</span><span class="n">nodes</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/econ_network/count_bundled-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/econ_network/count_bundled-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/econ_network/count_bundled-1400.webp"></source> <img src="/assets/img/econ_network/count_bundled.png" width="600" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Not a bad start, but not perfect either. You might have noticed, that we did not use the edge weights, therefore the edge shades represent the number of edges, not the sum of their weights. Unfortunately, shading based on the sum of weights is not as easy as I would like it to be. The problem is that the <code class="language-plaintext highlighter-rouge">edgepaths</code>attribute of a <code class="language-plaintext highlighter-rouge">Graph</code> object (which is an <code class="language-plaintext highlighter-rouge">EdgePath</code> object itself) does not contain the weight. As the <code class="language-plaintext highlighter-rouge">datashade</code> function gets this object for shading the nodes, it cannot see the weights, and as a result, supplying <code class="language-plaintext highlighter-rouge">datashader.sum(Weight)</code> as an aggregation function will not work.</p> <p>We can solve this by creating an <code class="language-plaintext highlighter-rouge">EdgePath</code>-like object ourselves, which will nevertheless have a <code class="language-plaintext highlighter-rouge">Weight</code> value dimension, and supplying that to <code class="language-plaintext highlighter-rouge">datashade</code>. We can use the <code class="language-plaintext highlighter-rouge">connect_edges</code> and <code class="language-plaintext highlighter-rouge">hammer_bundle</code> functions from the <code class="language-plaintext highlighter-rouge">datashader.bundling</code> module to create the dataframes containing the edge path, separated by <code class="language-plaintext highlighter-rouge">NaN</code> rows so that different edges will not be connected. If they are given a <code class="language-plaintext highlighter-rouge">weight</code> attribute, the resulting <code class="language-plaintext highlighter-rouge">pandas.DataFrame</code> will also contain a <code class="language-plaintext highlighter-rouge">weight</code> column. Then a <code class="language-plaintext highlighter-rouge">Path</code> object can be created having the coordinates of the paths as key dimensions and the weights as a value dimension. Finally, this <code class="language-plaintext highlighter-rouge">Path</code> object can be datashaded, and the sum of weights can be used as an aggregator function. The nodes are then added to the plot just like before.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">datashader</span> <span class="k">as</span> <span class="n">ds</span>
<span class="kn">from</span> <span class="n">datashader.bundling</span> <span class="kn">import</span> <span class="n">hammer_bundle</span><span class="p">,</span> <span class="n">connect_edges</span>

<span class="n">conn_edge_df</span> <span class="o">=</span> <span class="nf">connect_edges</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span> <span class="n">edge_df</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">)</span>
<span class="n">edge_paths</span> <span class="o">=</span> <span class="n">hv</span><span class="p">.</span><span class="nc">Path</span><span class="p">([</span><span class="n">conn_edge_df</span><span class="p">.</span><span class="n">values</span><span class="p">],</span> <span class="n">vdims</span><span class="o">=</span><span class="sh">"</span><span class="s">Weight</span><span class="sh">"</span><span class="p">)</span>

<span class="n">bundled_edge_df</span> <span class="o">=</span> <span class="nf">hammer_bundle</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span> <span class="n">edge_df</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">)</span>
<span class="n">bundled_paths</span> <span class="o">=</span> <span class="n">hv</span><span class="p">.</span><span class="nc">Path</span><span class="p">([</span><span class="n">bundled_edge_df</span><span class="p">.</span><span class="n">values</span><span class="p">],</span> <span class="n">vdims</span><span class="o">=</span><span class="sh">"</span><span class="s">Weight</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">opts</span> <span class="n">Nodes</span> <span class="p">[</span><span class="n">color_index</span><span class="o">=</span><span class="sh">'</span><span class="s">Category</span><span class="sh">'</span> <span class="n">size_index</span><span class="o">=</span><span class="sh">'</span><span class="s">log_degree</span><span class="sh">'</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span> <span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">colors</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
<span class="o">%%</span><span class="n">opts</span> <span class="n">Graph</span> <span class="p">[</span><span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span>
<span class="nf">datashade</span><span class="p">(</span><span class="n">edge_paths</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="sh">'</span><span class="s">eq_hist</span><span class="sh">'</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">cyan</span><span class="sh">'</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">aggregator</span><span class="o">=</span><span class="n">ds</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="sh">'</span><span class="s">Weight</span><span class="sh">'</span><span class="p">))</span> <span class="o">*</span>\
    <span class="n">bundled_graph</span><span class="p">.</span><span class="n">nodes</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/econ_network/sum_edges-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/econ_network/sum_edges-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/econ_network/sum_edges-1400.webp"></source> <img src="/assets/img/econ_network/sum_edges.png" width="600" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">opts</span> <span class="n">Nodes</span> <span class="p">[</span><span class="n">color_index</span><span class="o">=</span><span class="sh">'</span><span class="s">Category</span><span class="sh">'</span> <span class="n">size_index</span><span class="o">=</span><span class="sh">'</span><span class="s">log_degree</span><span class="sh">'</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span> <span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">colors</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>
<span class="o">%%</span><span class="n">opts</span> <span class="n">Graph</span> <span class="p">[</span><span class="n">width</span><span class="o">=</span><span class="mi">600</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span> <span class="n">xaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">yaxis</span><span class="o">=</span><span class="bp">None</span> <span class="n">bgcolor</span><span class="o">=</span><span class="sh">"</span><span class="s">black</span><span class="sh">"</span> <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">hover</span><span class="sh">"</span><span class="p">]]</span>
<span class="nf">datashade</span><span class="p">(</span><span class="n">bundled_paths</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="sh">'</span><span class="s">eq_hist</span><span class="sh">'</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">cyan</span><span class="sh">'</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">aggregator</span><span class="o">=</span><span class="n">ds</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="sh">'</span><span class="s">Weight</span><span class="sh">'</span><span class="p">))</span> <span class="o">*</span>\
    <span class="n">bundled_graph</span><span class="p">.</span><span class="n">nodes</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/econ_network/sum_bundled-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/econ_network/sum_bundled-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/econ_network/sum_bundled-1400.webp"></source> <img src="/assets/img/econ_network/sum_bundled.png" width="600" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="further-refinements">Further refinements</h2> <p>Almost there. The last detail would be to color the edges using the colors of the nodes they connect (ideally, the edge colors would be gradients between the source and target node colors). Unfortunately, there are multiple issues with this.</p> <p>First, the dataframes resulting from the <code class="language-plaintext highlighter-rouge">connect_edges</code> and <code class="language-plaintext highlighter-rouge">hammer_bundle</code> functions do not have an id by default, so joining them to node or edge attributes is not straightforward. The two functions have an <code class="language-plaintext highlighter-rouge">include_edge_id</code> argument, which sounds like it should solve this, but setting it to either <code class="language-plaintext highlighter-rouge">True</code> or the name of a column crashes the interpreter (at least in this example). Might be a bug. Nevertheless, one could certainly write a custom <code class="language-plaintext highlighter-rouge">connect_edges</code> function, and probably joining edge attributes to the result of <code class="language-plaintext highlighter-rouge">hammer_bundle</code> is also feasible, but it would be an awful lot of bother.</p> <p>Another problem is that there is no <code class="language-plaintext highlighter-rouge">sum_cat</code> aggregation function in datashader. There is <code class="language-plaintext highlighter-rouge">count_cat</code>, but then we lose the weight information. We could also shade the categories separately and <code class="language-plaintext highlighter-rouge">stack</code> them on top of each other, but <del>then the stacking order would matter a lot</del> (correction: by using the <code class="language-plaintext highlighter-rouge">how='add'</code> argument it would not). Neither of these options is optimal.</p> <p>What we did back then was exporting the network to a <code class="language-plaintext highlighter-rouge">graphml</code> file, and loading it into <a href="https://gephi.org/" target="_blank" rel="noopener noreferrer">Gephi</a> (a graph visualization tool) to make the visualization. It is a WYSIWYG-type program, so we could easily fiddle around with various parameters until we got the desired result. I think the final product is pretty good. You can find an <code class="language-plaintext highlighter-rouge">svg</code> version <a href="https://stanmart.github.io/assets/img/econ_network/full_graph.svg">here</a>.</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/econ_network/full_graph-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/econ_network/full_graph-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/econ_network/full_graph-1400.webp"></source> <img src="/assets/img/econ_network/full_graph.png" class="img-fluid rounded z-depth-1" width="600" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>While the fact that the final chapter in a Python dataviz article is to use another software for better results might seem a litle dispiriting at first, i think the main takaway is this: <em>use the right tool for the job</em>. For visualizing this moderate-sized network, the right tool seems to be a dedicated graph visualization software.</p> <p>We managed to create pretty good graphs using <code class="language-plaintext highlighter-rouge">holoviews</code> and <code class="language-plaintext highlighter-rouge">datashader</code>, but for the reasons listed above, these packages are not on par with Gephi yet, as far as graph visualization goes. But it is not neccesssarily a bad thing. For one, the former libraries have a much broader scope than just graphs and networks, so it is not surprising that they cannot compete with a specialist. Also, they may improve a lot in the future, as they are both relatively new. And you have to remember that it was a moderate-sized graph. For one with hundreds of thousands of nodes and millions of nodes, datashading might be the only reasonable option, and may come up on top even with its current limitations.</p> <p>Hope you enjoyed this write-up. The concluding part of this series will deal with modelling this network.</p> </article> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container"> Â© Copyright 2025 Martin Stancsics. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> </body> </html>